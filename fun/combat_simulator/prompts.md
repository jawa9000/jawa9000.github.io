GoalCreate a comprehensive test suite for the provided script.js (containing the CombatSimulator class) and omni_monster.js (monster data) files. The test suite must ensure code logic integrity, feature stability, and correct user output (Combat Log and UI) against future changes and bug fixes.Testing Framework & SetupFramework: Use Jest as the testing framework.Environment: The tests should run in a Node.js environment.Dependency Handling:Since script.js contains DOM interactions (initializeEventListeners, updateDisplay), use Jest's mocking features or jsdom (if necessary) to simulate the browser environment for E2E tests.For Unit Tests, use Spies/Mocks on methods like this.logMessage to verify that the correct log output is generated by the class logic without needing a real UI.The test file structure should be self-contained.Required Test Categories1. Unit Tests (Focus on CombatSimulator Class Logic)These tests must isolate and verify single methods within script.js.State Initialization: Verify the initial values of combatants ([]), combatActive (false), and combatRound (0) after the constructor runs.Condition Expiration:Test processTimedConditions(): Verify that a condition's duration is correctly decremented by 1 after one round.Test Condition Removal: Assert that a condition is removed from a combatant's conditions array when its duration drops to 0 or less.Log Message Verification (Mocking): Use a Jest Spy on the logMessage method to ensure that when a condition expires, the exact message format ("⌛ [Combatant]'s [condition] expires.") is generated and logged.Monster Data Structure: Import and iterate over the monster data from omni_monster.js and script.js to ensure every monster object has essential, non-null fields (e.g., name, "armor class", "hit points").2. Integration Tests (Focus on Workflow)These tests must verify the correct interaction between multiple methods.Full Combat Flow: Simulate a combat scenario (e.g., Bandit vs. Skeleton) from start to finish, ensuring that:Combatants are correctly added and initialized.Initiative is rolled and the initiativeOrder array is populated correctly.Turns are processed until a winner is determined.Surprise Round Logic: Verify that if surprisedTeam is set, combatants on that team are correctly skipped during the first combat round.Damage Calculation: Create a mock attack scenario and assert that the damage calculated and applied to the target combatant's HP is correct, accounting for potential AC misses/hits.3. End-to-End (E2E) / UI Interaction Tests (Focus on Log and Buttons)These tests must simulate user actions and verify the resulting changes in the display, especially the Combat Log. (Simulate this using a mock DOM environment).Button Functionality Verification:Simulate clicking the "Add Monster" button and assert that the internal combatants array updates correctly.Simulate clicking the "Start Combat" button and verify that the internal combatActive state changes to true and the combatRound counter increments.Combat Log Content Verification (Crucial): Run a short simulation (e.g., 2 rounds) and then inspect the simulated DOM element representing the Combat Log. Assert that the log element:Contains the expected messages for Attack Hits/Misses.Contains the expected messages for Condition Expiration (e.g., the ⌛ message).Contains the final Combat End message.